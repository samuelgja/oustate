import { Emitter, EmitterSubscribe } from './emitters/create-emitter'
import { PromiseData, PromiseStatus } from './computed/computed-types'

export type Key = string | number | symbol
export type IsSame<T = unknown> = (a: T, b: T) => boolean
export type Primitive = string | number | boolean | bigint | symbol | null | undefined
export type OnFinish<T> = (options: { hasError: boolean; data: T | unknown }) => void
export type StateInternal<T> = T extends Record<Key, unknown> ? T : T
export interface StateOptions<T> {
  isSame?: IsSame<T>
  onSet?: (oldValue: T, setStateCallback: () => T) => T
}

export type SetStateValue<T> = ((value: T) => T) | T
export type StateValue<T, S> = undefined extends S ? T : S
export type SetState<T> = (state: SetStateValue<T>) => void
export type GetState<T> = () => T

export type FamilySubscribe<T> = (key: Key, listener: (parameter: SubscribeFamilyParameters<T>) => void) => void
export interface SubscribeParameters<T = unknown> {
  prev: T
  next: T
}

export interface SubscribeFamilyParameters<T> extends SubscribeParameters<T> {
  key: Key
}

export enum SubscribeParametersType {
  END = 'end',
  CANCELED = 'canceled',
  THROW = 'throw',
  START = 'start',
}
export interface SubscribeParametersMessage {
  type: SubscribeParametersType
  updateVersion: number
  isAsync?: boolean
  is: StateKeys
}
export interface SubscribeInternalParametersEnd extends SubscribeParametersMessage {
  type: SubscribeParametersType.END
  stateId: Key
  prev: unknown
  next: unknown
  isSame: boolean
}

export interface SubscribeInternalParametersStart extends SubscribeParametersMessage {
  type: SubscribeParametersType.START
  stateId: Key
}

export interface SubscribeInternalParametersCanceled extends SubscribeParametersMessage {
  type: SubscribeParametersType.CANCELED
  stateId: Key
}
export interface SubscribeInternalParametersThrow extends SubscribeParametersMessage {
  type: SubscribeParametersType.THROW
  stateId: Key
  error: unknown
}

export type SubscribeInternalParameters =
  | SubscribeInternalParametersEnd
  | SubscribeInternalParametersStart
  | SubscribeInternalParametersCanceled
  | SubscribeInternalParametersThrow

export type StateSubscribe<T> = EmitterSubscribe<SubscribeParameters<T>>
export type SubscribeInternal = EmitterSubscribe<SubscribeInternalParameters>

export interface StateDataInternal<T = unknown, A = Awaited<T>> {
  cachedAwaited: A
  cached?: T
  isAsync?: boolean
  isDead?: boolean
  isResolving?: boolean
  isResolvingStateId?: Key
  isInitialized: boolean
  updateVersion: number
}

export enum StateKeys {
  IS_COMPUTED = 'isSelector',
  IS_STATE = 'isState',
  IS_STATE_FAMILY = 'isFamily',
}

export interface CommonFunctions<T> {
  __tag: T
  is: StateKeys
}
export interface AtomState<T> extends CommonFunctions<T> {
  /**
   * Set new state value
   */
  setState: SetState<T>
  /**
   * Get current state value
   */
  getState: GetState<T>
  /**
   * Subscribe to state changes - if it's state family - it will subscribe to all family members
   */
  subscribe: StateSubscribe<T>
  /**
   * Clear state to default value if it's basic atom - if it's family - it will clear all family members
   */
  clear: () => void
  /**
   * unique state id - generated by library
   */
  id: Key
  /**
   * State identifier
   */
  is: StateKeys.IS_STATE | StateKeys.IS_STATE_FAMILY
  /**
   * Internal state data
   */
  __internal: {
    getSnapshot: GetState<SelectorSnapshotData<T, T>>
    __sub: SubscribeInternal
    __emitter: Emitter<T>
    __cacheEmitter: Emitter<T>
    __promiseEmitter: Emitter<PromiseData>
    __promiseSetter: (status: PromiseStatus) => void
    resolvePromises: (data: T) => void
  }
}

export interface SelectorSnapshotData<T = unknown, A = Awaited<T>> {
  promise?: Promise<SubscribeInternalParameters>
  status: PromiseStatus
  data: A
}
export interface ComputedState<T> extends CommonFunctions<T> {
  /**
   * Get computed state value - it always return promise - either computed is not promise.
   */
  getState: GetState<Promise<T>>
  /**
   * Subscribe to computed state changes
   */
  subscribe: StateSubscribe<T>
  /**
   * Computed unique identifier
   */
  id: Key
  /**
   * Computed identifier
   */
  is: StateKeys.IS_COMPUTED
  /**
   * Internal computed data
   */
  __internal: {
    __sub: SubscribeInternal
    __emitter: Emitter<T>
    __cacheEmitter: Emitter<T>
    getSnapshot: GetState<SelectorSnapshotData<T>>
    __promiseEmitter: Emitter<PromiseData>
  }
}

export interface ComputedFamilyState<T> {
  (key: Key): ComputedState<T>
  /**
   * Subscribe to specific family member
   */
  subscribe: FamilySubscribe<T>
  /**
   * Clear specific family member
   */
  clear: () => void
  /**
   * State identifier
   */
  id: Key
}

export type SetStateFamily<T> = (key: Key, state: T) => void
export type GetStateFamily<T> = (key: Key) => T

export interface AtomFamily<T> {
  (key: Key): AtomState<T>
  /**
   * Subscribe to specific family member
   */
  subscribe: FamilySubscribe<T>
  /**
   * Clear specific family member
   */
  clear: () => void
  /**
   * State identifier
   */
  id: Key
}

export type StateAll<T> = AtomState<T> | ComputedState<T>
