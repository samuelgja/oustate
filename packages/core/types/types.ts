import { Emitter, EmitterSubscribe } from '../emitters/create-emitter'
import { PromiseData, PromiseStatus } from './computed-types'

/**
 * Key identifier for family state.
 */
export type Key = string | number | symbol
/**
 * Equality check function.
 */
export type IsSame<T = unknown> = (a: T, b: T) => boolean

export type OnFinish<T> = (options: { hasError: boolean; data: T | unknown }) => void
export type StateInternal<T> = T extends Record<Key, unknown> ? T : T
export interface StateOptions<T> {
  isSame?: IsSame<T>
  onSet?: (oldValue: T, setCallback: (draft: T) => T) => T
}

/**
 * Set new state value function.
 */
export type setValue<T> = ((value: T) => T) | T

/**
 * Set new state function
 */
export type StateValue<T, S> = undefined extends S ? T : S
export type set<T> = (state: setValue<T>) => void

export type setFamily<T> = (key: Key, state: T) => void
export type GetStateFamily<T> = (key: Key) => T
/**
 * Getting state value function.
 */
export type GetState<T> = () => T

/**
 * State family subscriber
 */
export type FamilySubscribe<T> = (key: Key, listener: (parameter: SubscribeFamilyParameters<T>) => void) => void
export interface SubscribeParameters<T = unknown> {
  prev: T
  next: T
}

export interface SubscribeFamilyParameters<T> extends SubscribeParameters<T> {
  key: Key
}

export enum SubscribeParametersType {
  END = 'end',
  CANCELED = 'canceled',
  THROW = 'throw',
  START = 'start',
}
export interface SubscribeParametersMessage {
  type: SubscribeParametersType
  updateVersion: number
  isAsync?: boolean
  is: StateKeys
}
export interface SubscribeInternalParametersEnd extends SubscribeParametersMessage {
  type: SubscribeParametersType.END
  stateId: Key
  prev: unknown
  next: unknown
  isSame: boolean
}

export interface SubscribeInternalParametersStart extends SubscribeParametersMessage {
  type: SubscribeParametersType.START
  stateId: Key
}

export interface SubscribeInternalParametersCanceled extends SubscribeParametersMessage {
  type: SubscribeParametersType.CANCELED
  stateId: Key
}
export interface SubscribeInternalParametersThrow extends SubscribeParametersMessage {
  type: SubscribeParametersType.THROW
  stateId: Key
  error: unknown
}

export type SubscribeInternalParameters =
  | SubscribeInternalParametersEnd
  | SubscribeInternalParametersStart
  | SubscribeInternalParametersCanceled
  | SubscribeInternalParametersThrow

export type StateSubscribe<T> = EmitterSubscribe<SubscribeParameters<T>>
export type SubscribeInternal = EmitterSubscribe<SubscribeInternalParameters>

export interface StateDataInternal<T = unknown, A = Awaited<T>> {
  cachedAwaited: A
  cached?: T
  isAsync?: boolean
  isDead?: boolean
  isResolving?: boolean
  isResolvingStateId?: Key
  isInitialized: boolean
  updateVersion: number
}

export enum StateKeys {
  IS_COMPUTED = 'isSelector',
  IS_STATE = 'isState',
  IS_STATE_FAMILY = 'isFamily',
}

export interface CommonFunctions<T> {
  __tag: T
  is: StateKeys
  /**
   * Subscribe to computed state changes
   */
  subscribe: StateSubscribe<T>

  /**
   * Clear state to default value if it's basic atom - if it's family - it will clear all family members
   */
  clear: () => void
}
export interface AtomState<T> extends CommonFunctions<T> {
  /**
   * Set new state value
   */
  set: set<T>
  /**
   * Get current state value
   */
  get: GetState<T>
  /**
   * unique state id - generated by library
   */
  id: Key
  /**
   * State identifier
   */
  is: StateKeys.IS_STATE | StateKeys.IS_STATE_FAMILY

  slice: <S>(selector: (value: T) => S, isSame?: IsSame<S>) => ComputedState<StateInternal<S>>

  asHook: () => <S>(selector?: (state: T) => S, isEqual?: IsSame<S>) => StateValue<T, S>
  /**
   * Internal state data
   */
  __internal: {
    getSnapshot: GetState<SelectorSnapshotData<T, T>>
    __sub: SubscribeInternal
    __emitter: Emitter<T>
    __cacheEmitter: Emitter<T>
    __promiseEmitter: Emitter<PromiseData>
    __promiseSetter: (status: PromiseStatus) => void
    resolvePromises: (data: T) => void
  }
}

export interface SelectorSnapshotData<T = unknown, A = Awaited<T>> {
  promise?: Promise<SubscribeInternalParameters>
  status: PromiseStatus
  data: A
}
export interface ComputedState<T> extends CommonFunctions<T> {
  /**
   * Get computed state value - it always return promise - either computed is not promise.
   */
  get: GetState<Promise<T>>
  /**
   * Computed unique identifier
   */
  id: Key
  /**
   * Computed identifier
   */
  is: StateKeys.IS_COMPUTED
  /**
   * Internal computed data
   */
  __internal: {
    __sub: SubscribeInternal
    __emitter: Emitter<T>
    __cacheEmitter: Emitter<T>
    getSnapshot: GetState<SelectorSnapshotData<T>>
    __promiseEmitter: Emitter<PromiseData>
  }
}

export interface Family<State, ParsedState> {
  /**
   * Callable function to get family member state
   */
  (key: Key): ParsedState
  /**
   * Subscribe to specific family member
   */
  subscribe: FamilySubscribe<State>
  /**
   * Clear specific family member
   */
  clear: () => void
  /**
   * State identifier
   */
  id: Key
}

export type ComputedFamilyState<T> = Family<T, ComputedState<T>>

export type AtomFamily<T> = Family<T, AtomState<T>>

export type StateAll<T> = AtomState<T> | ComputedState<T>
